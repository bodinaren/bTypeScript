import * as Util from "../util";
export default class List<T> {
    _source: T[];
    length: number;
    constructor(source?: T[]);
    toArray(): T[];
    add(item: T): this;
    static add<T>(source: T[], item: T): T[];
    addRange(collection: T[] | List<T>): this;
    static addRange<T>(source: T[], collection: T[] | List<T>): T[];
    asReadOnly(): List<T>;
    forEach(callback: Util.ILoopFunction<T>): void;
    static forEach<T>(source: T[], callback: Util.ILoopFunction<T>): void;
    indexOf(item: T, index?: number, count?: number): number;
    static indexOf<T>(source: T[], item: T, index?: number, count?: number): number;
    lastIndexOf(item: T, index?: number, count?: number): number;
    static lastIndexOf<T>(source: T[], item: T, index?: number, count?: number): number;
    insert(index: number, item: T): this;
    static insert<T>(source: T[], index: number, item: T): T[];
    insertRange(index: number, collection: T[] | List<T>): this;
    static insertRange<T>(source: T[], index: number, collection: T[] | List<T>): T[];
    get(index: number): T;
    set(index: number, item: T): void;
    remove(item: T): this;
    static remove<T>(source: T[], item: T): T[];
    removeAll(predicate?: Util.IPredicate<T>): this;
    static removeAll<T>(source: T[], predicate?: Util.IPredicate<T>): T[];
    removeAt(index: number): this;
    static removeAt<T>(source: T[], index: number): T[];
    removeRange(index: number, count: number): this;
    static removeRange<T>(source: T[], index: number, count: number): T[];
    clear(): this;
    static clear<T>(source: T[]): T[];
    count(predicate?: Util.IPredicate<T>): number;
    static count<T>(source: T[], predicate?: Util.IPredicate<T>): number;
    reverse(index?: number, count?: number): this;
    static reverse<T>(source: T[], index?: number, count?: number): T[];
    static range(start: number, count: number): List<number>;
}
